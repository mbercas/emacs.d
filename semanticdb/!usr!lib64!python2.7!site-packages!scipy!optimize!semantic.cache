;; Object optimize/
;; SEMANTICDB Tags save file
(semanticdb-project-database-file "optimize/"
  :tables
  (list
    (semanticdb-table "minpack.py"
      :major-mode 'python-mode
      :tags 
        '( ("__future__" include nil nil [1 65])
            ("warnings" include nil nil [67 82])
            ("_minpack" include nil nil [90 105])
            ("numpy" include nil nil [107 349])
            ("_check_unknown_options" include nil nil [365 402])
            ("Result" include nil nil [365 402])
            ("error" variable nil nil [404 426])
            ("__all__" variable nil nil [428 487])
            ("_check_func" function (:arguments 
              ( ("checker" variable nil (reparse-symbol function_parameters) [505 512])
                ("argname" variable nil (reparse-symbol function_parameters) [514 521])
                ("thefunc" variable nil (reparse-symbol function_parameters) [523 530])
                ("x0" variable nil (reparse-symbol function_parameters) [532 534])
                ("args" variable nil (reparse-symbol function_parameters) [536 540])
                ("numinputs" variable nil (reparse-symbol function_parameters) [542 551])
                ("output_shape" variable nil (reparse-symbol function_parameters) [553 565]))              ) nil [489 1327])
            ("fsolve" function
               (:documentation "
    Find the roots of a function.

    Return the roots of the (non-linear) equations defined by
    ``func(x) = 0`` given a starting estimate.

    Parameters
    ----------
    func : callable ``f(x, *args)``
        A function that takes at least one (possibly vector) argument.
    x0 : ndarray
        The starting estimate for the roots of ``func(x) = 0``.
    args : tuple, optional
        Any extra arguments to `func`.
    fprime : callable(x), optional
        A function to compute the Jacobian of `func` with derivatives
        across the rows. By default, the Jacobian will be estimated.
    full_output : bool, optional
        If True, return optional outputs.
    col_deriv : bool, optional
        Specify whether the Jacobian function computes derivatives down
        the columns (faster, because there is no transpose operation).
    xtol : float
        The calculation will terminate if the relative error between two
        consecutive iterates is at most `xtol`.
    maxfev : int, optional
        The maximum number of calls to the function. If zero, then
        ``100*(N+1)`` is the maximum where N is the number of elements
        in `x0`.
    band : tuple, optional
        If set to a two-sequence containing the number of sub- and
        super-diagonals within the band of the Jacobi matrix, the
        Jacobi matrix is considered banded (only for ``fprime=None``).
    epsfcn : float, optional
        A suitable step length for the forward-difference
        approximation of the Jacobian (for ``fprime=None``). If
        `epsfcn` is less than the machine precision, it is assumed
        that the relative errors in the functions are of the order of
        the machine precision.
    factor : float, optional
        A parameter determining the initial step bound
        (``factor * || diag * x||``).  Should be in the interval
        ``(0.1, 100)``.
    diag : sequence, optional
        N positive entries that serve as a scale factors for the
        variables.

    Returns
    -------
    x : ndarray
        The solution (or the result of the last iteration for
        an unsuccessful call).
    infodict : dict
        A dictionary of optional outputs with the keys:

          * 'nfev' : number of function calls
          * 'njev' : number of Jacobian calls
          * 'fvec' : function evaluated at the output
          * 'fjac' : the orthogonal matrix, q, produced by the QR
                    factorization of the final approximate Jacobian
                    matrix, stored column wise
          * 'r' : upper triangular matrix produced by QR factorization
                  of the same matrix
          * 'qtf': the vector ``(transpose(q) * fvec)``

    ier : int
        An integer flag.  Set to 1 if a solution was found, otherwise refer
        to `mesg` for more information.
    mesg : str
        If no solution is found, `mesg` details the cause of failure.

    See also
    --------
    root : Interface to root finding algorithms for multivariate
           functions. See the 'hybr' `method` in particular.

    Notes
    -----
    ``fsolve`` is a wrapper around MINPACK's hybrd and hybrj algorithms.

    "
                :arguments 
                  ( ("func" variable nil (reparse-symbol function_parameters) [1340 1344])
                    ("x0" variable nil (reparse-symbol function_parameters) [1346 1348])
                    ("args" variable nil (reparse-symbol function_parameters) [1350 1354])
                    ("fprime" variable nil (reparse-symbol function_parameters) [1359 1365])
                    ("full_output" variable nil (reparse-symbol function_parameters) [1372 1383])
                    ("col_deriv" variable nil (reparse-symbol function_parameters) [1398 1407])
                    ("xtol" variable nil (reparse-symbol function_parameters) [1411 1415])
                    ("maxfev" variable nil (reparse-symbol function_parameters) [1428 1434])
                    ("band" variable nil (reparse-symbol function_parameters) [1438 1442])
                    ("epsfcn" variable nil (reparse-symbol function_parameters) [1460 1466])
                    ("factor" variable nil (reparse-symbol function_parameters) [1473 1479])
                    ("diag" variable nil (reparse-symbol function_parameters) [1485 1489]))                  )
                nil [1329 5292])
            ("_root_hybr" function
               (:documentation "
    Find the roots of a multivariate function using MINPACK's hybrd and
    hybrj routines (modified Powell method).

    Options for the hybrd algorithm are:
        col_deriv : bool
            Specify whether the Jacobian function computes derivatives down
            the columns (faster, because there is no transpose operation).
        xtol : float
            The calculation will terminate if the relative error between two
            consecutive iterates is at most `xtol`.
        maxfev : int
            The maximum number of calls to the function. If zero, then
            ``100*(N+1)`` is the maximum where N is the number of elements
            in `x0`.
        band : tuple
            If set to a two-sequence containing the number of sub- and
            super-diagonals within the band of the Jacobi matrix, the
            Jacobi matrix is considered banded (only for ``fprime=None``).
        eps : float
            A suitable step length for the forward-difference
            approximation of the Jacobian (for ``fprime=None``). If
            `eps` is less than the machine precision, it is assumed
            that the relative errors in the functions are of the order of
            the machine precision.
        factor : float
            A parameter determining the initial step bound
            (``factor * || diag * x||``).  Should be in the interval
            ``(0.1, 100)``.
        diag : sequence
            N positive entries that serve as a scale factors for the
            variables.

    This function is called by the `root` function with `method=hybr`. It
    is not supposed to be called directly.
    "
                :arguments 
                  ( ("func" variable nil (reparse-symbol function_parameters) [5308 5312])
                    ("x0" variable nil (reparse-symbol function_parameters) [5314 5316])
                    ("args" variable nil (reparse-symbol function_parameters) [5318 5322])
                    ("jac" variable nil (reparse-symbol function_parameters) [5327 5330])
                    ("col_deriv" variable nil (reparse-symbol function_parameters) [5352 5361])
                    ("xtol" variable nil (reparse-symbol function_parameters) [5365 5369])
                    ("maxfev" variable nil (reparse-symbol function_parameters) [5383 5389])
                    ("band" variable nil (reparse-symbol function_parameters) [5393 5397])
                    ("eps" variable nil (reparse-symbol function_parameters) [5404 5407])
                    ("factor" variable nil (reparse-symbol function_parameters) [5429 5435])
                    ("diag" variable nil (reparse-symbol function_parameters) [5441 5445])
                    ("full_output" variable nil (reparse-symbol function_parameters) [5452 5463])
                    ("unknown_options" variable nil (reparse-symbol function_parameters) [5467 5484]))                  )
                nil [5293 9531])
            ("leastsq" function
               (:documentation "
    Minimize the sum of squares of a set of equations.

    ::

        x = arg min(sum(func(y)**2,axis=0))
                 y

    Parameters
    ----------
    func : callable
        should take at least one (possibly length N vector) argument and
        returns M floating point numbers.
    x0 : ndarray
        The starting estimate for the minimization.
    args : tuple
        Any extra arguments to func are placed in this tuple.
    Dfun : callable
        A function or method to compute the Jacobian of func with derivatives
        across the rows. If this is None, the Jacobian will be estimated.
    full_output : bool
        non-zero to return all optional outputs.
    col_deriv : bool
        non-zero to specify that the Jacobian function computes derivatives
        down the columns (faster, because there is no transpose operation).
    ftol : float
        Relative error desired in the sum of squares.
    xtol : float
        Relative error desired in the approximate solution.
    gtol : float
        Orthogonality desired between the function vector and the columns of
        the Jacobian.
    maxfev : int
        The maximum number of calls to the function. If zero, then 100*(N+1) is
        the maximum where N is the number of elements in x0.
    epsfcn : float
        A suitable step length for the forward-difference approximation of the
        Jacobian (for Dfun=None). If epsfcn is less than the machine precision,
        it is assumed that the relative errors in the functions are of the
        order of the machine precision.
    factor : float
        A parameter determining the initial step bound
        (``factor * || diag * x||``). Should be in interval ``(0.1, 100)``.
    diag : sequence
        N positive entries that serve as a scale factors for the variables.

    Returns
    -------
    x : ndarray
        The solution (or the result of the last iteration for an unsuccessful
        call).
    cov_x : ndarray
        Uses the fjac and ipvt optional outputs to construct an
        estimate of the jacobian around the solution.  ``None`` if a
        singular matrix encountered (indicates very flat curvature in
        some direction).  This matrix must be multiplied by the
        residual variance to get the covariance of the
        parameter estimates -- see curve_fit.
    infodict : dict
        a dictionary of optional outputs with the key s::

            - 'nfev' : the number of function calls
            - 'fvec' : the function evaluated at the output
            - 'fjac' : A permutation of the R matrix of a QR
                     factorization of the final approximate
                     Jacobian matrix, stored column wise.
                     Together with ipvt, the covariance of the
                     estimate can be approximated.
            - 'ipvt' : an integer array of length N which defines
                     a permutation matrix, p, such that
                     fjac*p = q*r, where r is upper triangular
                     with diagonal elements of nonincreasing
                     magnitude. Column j of p is column ipvt(j)
                     of the identity matrix.
            - 'qtf'  : the vector (transpose(q) * fvec).

    mesg : str
        A string message giving information about the cause of failure.
    ier : int
        An integer flag.  If it is equal to 1, 2, 3 or 4, the solution was
        found.  Otherwise, the solution was not found. In either case, the
        optional output variable 'mesg' gives more information.

    Notes
    -----
    \"leastsq\" is a wrapper around MINPACK's lmdif and lmder algorithms.

    cov_x is a Jacobian approximation to the Hessian of the least squares
    objective function.
    This approximation assumes that the objective function is based on the
    difference between some observed target data (ydata) and a (non-linear)
    function of the parameters `f(xdata, params)` ::

           func(params) = ydata - f(xdata, params)

    so that the objective function is ::

           min   sum((ydata - f(xdata, params))**2, axis=0)
         params

    "
                :arguments 
                  ( ("func" variable nil (reparse-symbol function_parameters) [9545 9549])
                    ("x0" variable nil (reparse-symbol function_parameters) [9551 9553])
                    ("args" variable nil (reparse-symbol function_parameters) [9555 9559])
                    ("Dfun" variable nil (reparse-symbol function_parameters) [9564 9568])
                    ("full_output" variable nil (reparse-symbol function_parameters) [9575 9586])
                    ("col_deriv" variable nil (reparse-symbol function_parameters) [9602 9611])
                    ("ftol" variable nil (reparse-symbol function_parameters) [9615 9619])
                    ("xtol" variable nil (reparse-symbol function_parameters) [9632 9636])
                    ("gtol" variable nil (reparse-symbol function_parameters) [9661 9665])
                    ("maxfev" variable nil (reparse-symbol function_parameters) [9671 9677])
                    ("epsfcn" variable nil (reparse-symbol function_parameters) [9681 9687])
                    ("factor" variable nil (reparse-symbol function_parameters) [9694 9700])
                    ("diag" variable nil (reparse-symbol function_parameters) [9706 9710]))                  )
                nil [9533 17120])
            ("_general_function" function (:arguments 
              ( ("params" variable nil (reparse-symbol function_parameters) [17143 17149])
                ("xdata" variable nil (reparse-symbol function_parameters) [17151 17156])
                ("ydata" variable nil (reparse-symbol function_parameters) [17158 17163])
                ("function" variable nil (reparse-symbol function_parameters) [17165 17173]))              ) nil [17121 17220])
            ("_weighted_general_function" function (:arguments 
              ( ("params" variable nil (reparse-symbol function_parameters) [17252 17258])
                ("xdata" variable nil (reparse-symbol function_parameters) [17260 17265])
                ("ydata" variable nil (reparse-symbol function_parameters) [17267 17272])
                ("function" variable nil (reparse-symbol function_parameters) [17274 17282])
                ("weights" variable nil (reparse-symbol function_parameters) [17284 17291]))              ) nil [17221 17350])
            ("curve_fit" function
               (:documentation "
    Use non-linear least squares to fit a function, f, to data.

    Assumes ``ydata = f(xdata, *params) + eps``

    Parameters
    ----------
    f : callable
        The model function, f(x, ...).  It must take the independent
        variable as the first argument and the parameters to fit as
        separate remaining arguments.
    xdata : An N-length sequence or an (k,N)-shaped array
        for functions with k predictors.
        The independent variable where the data is measured.
    ydata : N-length sequence
        The dependent data --- nominally f(xdata, ...)
    p0 : None, scalar, or M-length sequence
        Initial guess for the parameters.  If None, then the initial
        values will all be 1 (if the number of parameters for the function
        can be determined using introspection, otherwise a ValueError
        is raised).
    sigma : None or N-length sequence
        If not None, it represents the standard-deviation of ydata.
        This vector, if given, will be used as weights in the
        least-squares problem.

    Returns
    -------
    popt : array
        Optimal values for the parameters so that the sum of the squared error
        of ``f(xdata, *popt) - ydata`` is minimized
    pcov : 2d array
        The estimated covariance of popt.  The diagonals provide the variance
        of the parameter estimate.

    See Also
    --------
    leastsq

    Notes
    -----
    The algorithm uses the Levenberg-Marquardt algorithm through `leastsq`.
    Additional keyword arguments are passed directly to that algorithm.

    Examples
    --------
    >>> import numpy as np
    >>> from scipy.optimize import curve_fit
    >>> def func(x, a, b, c):
    ...     return a*np.exp(-b*x) + c

    >>> x = np.linspace(0,4,50)
    >>> y = func(x, 2.5, 1.3, 0.5)
    >>> yn = y + 0.2*np.random.normal(size=len(x))

    >>> popt, pcov = curve_fit(func, x, yn)

    "
                :arguments 
                  ( ("f" variable nil (reparse-symbol function_parameters) [17365 17366])
                    ("xdata" variable nil (reparse-symbol function_parameters) [17368 17373])
                    ("ydata" variable nil (reparse-symbol function_parameters) [17375 17380])
                    ("p0" variable nil (reparse-symbol function_parameters) [17382 17384])
                    ("sigma" variable nil (reparse-symbol function_parameters) [17391 17396])
                    ("kw" variable nil (reparse-symbol function_parameters) [17403 17407]))                  )
                nil [17351 20593])
            ("check_gradient" function
               (:documentation "Perform a simple check on the gradient for correctness.

    "
                :arguments 
                  ( ("fcn" variable nil (reparse-symbol function_parameters) [20613 20616])
                    ("Dfcn" variable nil (reparse-symbol function_parameters) [20618 20622])
                    ("x0" variable nil (reparse-symbol function_parameters) [20624 20626])
                    ("args" variable nil (reparse-symbol function_parameters) [20628 20632])
                    ("col_deriv" variable nil (reparse-symbol function_parameters) [20637 20646]))                  )
                nil [20594 21364])
            ("fixed_point" function
               (:documentation "
    Find a fixed point of the function.

    Given a function of one or more variables and a starting point, find a
    fixed-point of the function: i.e. where ``func(x0) == x0``.

    Parameters
    ----------
    func : function
        Function to evaluate.
    x0 : array_like
        Fixed point of function.
    args : tuple, optional
        Extra arguments to `func`.
    xtol : float, optional
        Convergence tolerance, defaults to 1e-08.
    maxiter : int, optional
        Maximum number of iterations, defaults to 500.

    Notes
    -----
    Uses Steffensen's Method using Aitken's ``Del^2`` convergence acceleration.
    See Burden, Faires, \"Numerical Analysis\", 5th edition, pg. 80

    Examples
    --------
    >>> from scipy import optimize
    >>> def func(x, c1, c2):
    ....    return np.sqrt(c1/(x+c2))
    >>> c1 = np.array([10,12.])
    >>> c2 = np.array([3, 5.])
    >>> optimize.fixed_point(func, [1.2, 1.3], args=(c1,c2))
    array([ 1.4920333 ,  1.37228132])

    "
                :arguments 
                  ( ("func" variable nil (reparse-symbol function_parameters) [21451 21455])
                    ("x0" variable nil (reparse-symbol function_parameters) [21457 21459])
                    ("args" variable nil (reparse-symbol function_parameters) [21461 21465])
                    ("xtol" variable nil (reparse-symbol function_parameters) [21470 21474])
                    ("maxiter" variable nil (reparse-symbol function_parameters) [21481 21488]))                  )
                nil [21435 23480]))          
      :file "minpack.py"
      :pointmax 23480
      :fsize 23479
      :lastmodtime '(21076 28897 0 0)
      :unmatched-syntax '((FROM 350 . 354) (PERIOD 355 . 356) (FROM 83 . 87) (PERIOD 88 . 89))))
  :file "!usr!lib64!python2.7!site-packages!scipy!optimize!semantic.cache"
  :semantic-tag-version "2.0"
  :semanticdb-version "2.2")
